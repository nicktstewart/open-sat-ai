import { NextRequest, NextResponse } from "next/server";
import { safeValidateAnalysisPlan } from "@/lib/schemas/analysis-plan";

/**
 * System prompt for the planner LLM
 * This enforces strict output format and allowed operations
 */
const PLANNER_SYSTEM_PROMPT = `You are a satellite data analysis planner. Your job is to convert user queries into structured analysis plans.

ALLOWED ANALYSIS TYPES:
- ndvi_change: Calculate vegetation change between two periods
- ndvi_timeseries: Generate time series of vegetation index
- ndvi_anomaly: Detect vegetation anomalies
- seasonal_trend: Analyze seasonal vegetation patterns

ALLOWED DATASETS:
- sentinel2: Sentinel-2 optical imagery (10m resolution)
- landsat8: Landsat 8 optical imagery (30m resolution)
- modis: MODIS moderate resolution imagery (250m-1km)

ALLOWED OUTPUTS:
- map: Spatial visualization
- timeseries: Time series chart
- statistics: Summary statistics
- summary: Text summary

SUPPORTED LOCATIONS (use exact names or provide bbox):
- Tokyo: [139.5, 35.5, 139.9, 35.8]
- Osaka: [135.3, 34.5, 135.7, 34.8]
- Kyoto: [135.6, 34.9, 135.9, 35.1]

RULES:
1. Output ONLY valid JSON matching the schema
2. No explanations, no markdown, no extra text
3. Dates must be YYYY-MM-DD format
4. Time range cannot exceed 5 years
5. If query is unclear, make reasonable assumptions
6. Reject queries about non-vegetation topics

OUTPUT SCHEMA:
{
  "analysisType": "ndvi_change" | "ndvi_timeseries" | "ndvi_anomaly" | "seasonal_trend",
  "datasets": ["sentinel2" | "landsat8" | "modis"],
  "timeRange": {
    "start": "YYYY-MM-DD",
    "end": "YYYY-MM-DD"
  },
  "location": "Tokyo" | [west, south, east, north],
  "outputs": ["map" | "timeseries" | "statistics" | "summary"],
  "parameters": {} // optional
}`;

export async function POST(request: NextRequest) {
  try {
    const { query } = await request.json();

    if (!query || typeof query !== "string") {
      return NextResponse.json(
        { error: "Query is required and must be a string" },
        { status: 400 }
      );
    }

    // Check for OpenAI API key
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      return NextResponse.json(
        { error: "OpenAI API key not configured" },
        { status: 500 }
      );
    }

    // Call OpenAI API
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: PLANNER_SYSTEM_PROMPT,
          },
          {
            role: "user",
            content: query,
          },
        ],
        response_format: { type: "json_object" },
        temperature: 0.1,
        max_tokens: 500,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error("OpenAI API error:", error);
      return NextResponse.json(
        { error: "Failed to generate analysis plan" },
        { status: 500 }
      );
    }

    const data = await response.json();
    const planText = data.choices[0]?.message?.content;

    if (!planText) {
      return NextResponse.json(
        { error: "No plan generated by LLM" },
        { status: 500 }
      );
    }

    // Parse and validate the plan
    let planData;
    try {
      planData = JSON.parse(planText);
    } catch (e) {
      console.error("Failed to parse LLM response as JSON:", planText);
      return NextResponse.json(
        { error: "Invalid JSON response from LLM" },
        { status: 500 }
      );
    }

    // Validate against schema
    const validation = safeValidateAnalysisPlan(planData);

    if (!validation.success) {
      console.error("Plan validation failed:", validation.error);
      return NextResponse.json(
        {
          error: "Invalid analysis plan",
          details: validation.error.issues,
        },
        { status: 400 }
      );
    }

    // Return validated plan
    return NextResponse.json({
      plan: validation.data,
      raw: planData, // For debugging
    });
  } catch (error) {
    console.error("Planning error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
